\documentclass[a4paper,10pt,oneside,openany,final,article]{memoir}
\input{common}

\usepackage{minted}

\begin{document}
\title{A view of $0$ or $1$ elements: \tcode{views::maybe}}
\author{
Steve Downey \small(\href{mailto:sdowney@gmail.com}{sdowney@gmail.com}) \\
}
\date{} %unused. Type date explicitly below.
\maketitle

\begin{tabular}{ll}
  Document \#: & D1255R8 \\
  Date: &2022-07-06 \\
  Project: & Programming Language C++ \\
  Audience: & SG9, LEWG
\end{tabular}

\begin{abstract}
  This paper proposes \tcode{views::maybe} a range adaptor that produces a view with cardinality $0$ or $1$ which adapts copyable object types, values, and nullable types such as \tcode{std::optional} and pointer to object types.
\end{abstract}

\tableofcontents*

\chapter{Before / After Table}
\begin{tabular}{ ll }
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[fontsize=\footnotesize]{c++}
{
    auto&& opt = possible_value();
    if (opt) {
        // a few dozen lines ...
        use(*opt); // is *opt OK ?
    }
}

\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\footnotesize]{c++}

for (auto&& opt :
         views::maybe(possible_value())) {
    // a few dozen lines ...
    use(opt); // opt is OK
}

\end{minted}
\end{minipage}
\\ \midrule
\begin{minipage}[t]{0.45\columnwidth}
\begin{minted}[fontsize=\footnotesize]{c++}
 std::optional o{7};
 if (o) {
  *o = 9;
   std::cout << "o=" << *o << " prints 9\n";
 }
 std::cout << "o=" << *o << " prints 9\n";

\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[fontsize=\footnotesize]{c++}
 std::optional o{7};
 for (auto&& i : views::maybe(std::ref(o))) {
  i = 9;
   std::cout << "i=" << i << " prints 9\n";
 }
 std::cout << "o=" << *o << " prints 9\n";

\end{minted}
\end{minipage}
\\ \midrule
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[fontsize=\footnotesize]{c++}
std::vector<int> v{2, 3, 4, 5, 6, 7, 8, 9, 1};
auto test = [](int i) -> std::optional<int> {
    switch (i) {
    case 1:
    case 3:
    case 7:
    case 9:
        return i;
    default:
        return {};
    }
};

auto&& r =
    v | ranges::views::transform(test) |
    ranges::views::filter(
        [](auto x) { return bool(x); }) |
    ranges::views::transform(
        [](auto x) { return *x; }) |
    ranges::views::transform([](int i) {
        std::cout << i;
        return i;
    });
\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[fontsize=\footnotesize]{c++}
std::vector<int> v{2, 3, 4, 5, 6, 7, 8, 9, 1};
auto test = [](int i) -> std::optional<int> {
    switch (i) {
    case 1:
    case 3:
    case 7:
    case 9:
        return i;
    default:
        return {};
    }
};

auto&& r =
    v | ranges::views::transform(test) |
    ranges::views::transform(views::maybe) |
    ranges::views::join |
    ranges::views::transform([](int i) {
        std::cout << i;
        return i;
    });
 \end{minted}
 \end{minipage}
\end{tabular}

\chapter{Motivation}

In writing range transformation it is useful to be able to lift a value into a view that is either empty or contains the value. For types that are `nullable`, constructing an empty view for disengaged values and providing a view to the underlying value is useful as well. The adapter `views::single` fills a similar purpose for non-nullable values, lifting a single value into a view, and `views::empty` provides a range of no values of a given type. The type `views::maybe` can be used to unify `single` and `empty` into a single type for further processing. This is in particuluar useful when translating list comprehensions.

\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}{c++}
std::vector<std::optional<int>> v{
    std::optional<int>{42},
    std::optional<int>{},
    std::optional<int>{6 * 9}};

auto r = views::join(
    views::transform(v, views::maybe));

for (auto i : r) {
    std::cout << i; // prints 42 and 54
}
  \end{minted}
\end{minipage}


In addition to range transformation pipelines, \mintinline{C++}{views::maybe} can be used in range based for loops, allowing the nullable value to not be dereferenced within the body. This is of small value in small examples in contrast to testing the nullable in an if statement, but with longer bodies the dereference is often far away from the test. Often the first line in the body of the \mintinline{C++}{if} is naming the dereferenced nullable, and lifting the dereference into the for loop eliminates some boilerplate code, the same way that range based for loops do.

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}
{
    auto&& opt = possible_value();
    if (opt) {
        // a few dozen lines ...
        use(*opt); // is *opt OK ?
    }
}

for (auto&& opt :
     views::maybe(possible_value())) {
    // a few dozen lines ...
    use(opt); // opt is OK
}

\end{minted}
\end{minipage}

The view can be on a \mintinline{C++}{std::reference_wrapper}, allowing the underlying nullable to be modified:

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}
std::optional o{7};
for (auto&& i : views::maybe(std::ref(o))) {
    i = 9;
    std::cout << "i=" << i << " prints 9\n";
}
std::cout << "o=" << *o << " prints 9\n";

\end{minted}
\end{minipage}

Of course, if the nullable is empty, there is nothing in the view to modify.

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}

auto oe = std::optional<int>{};
for (int i : views::maybe(std::ref(oe)))
    std::cout << "i=" << i
              << '\n'; // does not print

\end{minted}
\end{minipage}

Converting an optional type into a view can make APIs that return optional types, such a lookup operations, easier to work with in range pipelines.

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}

std::unordered_set<int> set{1, 3, 7, 9};

auto flt = [=](int i) -> std::optional<int> {
    if (set.contains(i))
        return i;
    else
        return {};
};

for (auto i :
     ranges::iota_view{1, 10} |
         ranges::views::transform(flt)) {
    for (auto j : views::maybe(i)) {
        for (auto k :
             ranges::iota_view(0, j))
            std::cout << '\a';
        std::cout << '\n';
    }
}

\end{minted}
\end{minipage}


\chapter{Lazy monadic pythagorean triples}

Eric Niebler's pythagorean triple example, using current C++ and proposed views::maybe.

\begin{minipage}[t]{\columnwidth}
  \begin{minted} {c++}


// "and_then" creates a new view by applying
// a transformation to each element in an
// input range, and flattening the resulting
// range of ranges. A.k.a. bind (This uses
// one syntax for constrained lambdas in
// C++20.)
inline constexpr auto and_then = [](auto&& r, auto fun) {
    return decltype(r)(r) |
           std::ranges::views::transform(std::move(fun)) |
           std::ranges::views::join;
};

// "yield_if" takes a bool and a value and
// returns a view of zero or one elements.
inline constexpr auto yield_if = [](bool b, auto x) {
    return b ? maybe_view{std::move(x)}
             : maybe_view<decltype(x)>{};
};

void print_triples() {
    using std::ranges::views::iota;
    auto triples = and_then(iota(1), [](int z) {
        return and_then(iota(1, z + 1), [=](int x) {
            return and_then(iota(x, z + 1), [=](int y) {
                return yield_if(x * x + y * y == z * z,
                                std::make_tuple(x, y, z));
            });
        });
    });

    // Display the first 10 triples
    for (auto triple :
         triples | std::ranges::views::take(10)) {
        std::cout << '(' << std::get<0>(triple) << ','
                  << std::get<1>(triple) << ','
                  << std::get<2>(triple) << ')' << '\n';
    }
}

\end{minted}
\end{minipage}

The implementation of \tcode{yield_if} is essentially the type unification of \tcode{single} and \tcode{empty} into \tcode{maybe}, returning an empty on false, and a range containing one value on true.

\chapter{Proposal}

Add a range adaptor object \tcode{views::maybe}, returning a view over an object, capturing by value. For \exposid{nullable} objects, provide a zero size range for objects which are disengaged. A \exposid{nullable} object is one that is both contextually convertible to bool and for which the type produced by dereferencing is an equality preserving object. Non void pointers, `\tcode{std::optional}`, and the proposed  `\tcode{expected}` [@P0323R9] types all models \exposid{nullable}. Function pointers do not, as functions are not objects. Iterators do not generally model \exposid{nullable}, as they are not required to be contextually convertible to bool.


\chapter{Borrowed Range}
A borrowed_range is one whose iterators cannot be invalidated by ending the lifetime of the range. For \tcode{views::maybe}, the iterators are \tcode{T*}, where \tcode{T} is essentially the type of the dereferenced nullable. For raw pointers and reference_wrapper over \libconcept{nullable} types, the iterator for \tcode{maybe_view} points directly to the underlying object, and thus matches the semantics of \libconcept{borrowed_range}. This means that \tcode{maybe_view} is conditionally borrowed. A \tcode{maybe_view<shared_ptr>}, however, is not a borrowed range, as it participates in ownership of the shared_ptr and might invalidate the iterators if upon the end of its lifetime it is the last owner.

An example of code that is enabled by borrowed ranges, if unlikely code:

\begin{minipage}[t]{\columnwidth}
\begin{minted} {c++}
num = 42;
int k = *std::ranges::find(views::maybe(&num), num);
\end{minted}
\end{minipage}

Providing the facility is not a signficant cost, and conveys the semantics correctly, even if the simple examples are not hugely motivating. Particularly as there is no real implementation impact, other than providing template variable specializations for enable_borrowed_range.

\chapter{Design}

The basis of the design is to hybridize \tcode{views::single} and \tcode{views::empty}. If the view is over a value that is not \exposid{nullable} it is like a single view if constructed with a value, or is of size zero otherwise. For \exposid{nullable} types, if the underlying object claims to hold a value, as determined by checking if the object when converted to bool is true, \tcode{begin} and \tcode{end} of the view are equivalent to the address of the held value within the underlying object and one past the underlying object. If the underlying object does not have a value, \tcode{begin} and \tcode{end} return \tcode{nullptr}. \tcode{views::maybe} also has support for \tcode{std::reference_wrapper}, allowing writes through the iterator to pass through to the object held in the wrapper.


\chapter{Implementation}

A publically available implementation at \url{https://github.com/steve-downey/view_maybe} based on the Ranges implementation in libstdc++. There are no particular implementation difficulties or tricks. The declarations are essentially what is quoted in the Wording section and the implementations are described as effects.

\href{https://godbolt.org/\#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI\%2BAEaYxCDSAA6oCoRODB7evnoJSY4CQSHhLFEx0naYDilCBEzEBGk\%2Bfly2mPY5DJXVBHlhkdGxtlU1dRmNCgOdwd2FvZIAlLaoXsTI7BzmAMzByN5YANQma24IBARxCiAA9OfETADuAHTAhAheEV5KS7KMBHdoLOejmAAbpgALToVA3EIAT3OgLwmBuAH0WEwoVFziiAcR/ktYfCkSi0Zg8QjkaioncEPtsCYNABBWkMswbBhbLy7fZuYEOEjUxmM0boEAgVBxVpiTnBAjUnZZJIReiIwFiLyYCAzfZWemA1B4dA7N5qqU7AgatZauk6vU7KL8YiYDTq/kAdgtO3de1djI9OyYXiI5gAbEGdqKCHs1gARWWJeWK5XeNVmt0evBUHYQMMzPb0n0mL25n0ey6\%2BnZUBE7cEAL0YO1oEwUOzuze9RfdhogACos5qdiW8I3u2KdgB5ADSEYAYq33fnIzPPfP6XP\%2BdrdfqmFQCNFHdmXRa7Rm/QGzMHT6HhyAdnCEWcQISohA5XgFZglSqkzM98uC3SfSWmDLCtq1resQkbZs7gXDse3NPtzgvcMB1HMcXSXBlnXQxkrX1W0SEwLh1RzDCLUFYUwxSMRQ3zCxnRXc1GTTDNUG/EiF27CNowATk1BcyJQBZw05Tk9jMMxUH2ecxIjNwRI44SDlEsxZWIKVGx4gBWNwGHMMxeJ/dD\%2BLQf0ZJE3SJKjXTTMU\%2BSDjM6S4lUwR1JMLSdLE/SMKwtdrU3bdiEI1iaIFAghRFMVKNoajXTozDPMPCBjwk08QzwHYrxvG47wfNV\%2BPtKhMy/ILfx9NLJJ2HiGMLd0jME6y3CUvBJKshSGrKuzFKsxy1Iq1ztN0zyV3pWqTNapSLKk5Sxts2TOocpyCBctyBqqrzV0tdcbUwO1MDMJ0f1I0LhW5IhiElQQZUBGizFIHY1lu6Qdg027A1u51boADlurjbq4eiLSSk1MFGTi9g0qwNMjCBjTwbMQRlfiKIECUDilGVguqnYFBuQhkAQDNYc9FMfVEJQdi4EAF3dUnMDuynMeppgyedem/yLGmKtZn17QIRYGB2JrVrbLAqD9WgCC5j0eb5on/oXIa1tWxkkqDENiFBwFPVkzHriMYHjvxO8CF1hQ7RYCBt1GPdnW1tn3V14B9ZATK7xocXoggVyIahwHVA1V1peIfmIlQTwID93jMOt23ucMR27xd4VjcMU2SHNr3XJ9/1UB2COA8wXmg52TtVEjyNo4XB2ncTkBk4YVPiHThmPQzyHocEAXreJtsPRGoSOrazye6LQP\%2BcF7u8yj\%2BKSCPbPVfPNKr2ILu5eXAz1pw30t2iPaNQOkKwpO3lUYutZsGva7bvunZHuenZXp2d6di\%2BirftXulAct/vo1bqGYbhhGR1wriloOdaUZ9ZaY2xrjfG0MV7Nw5hTKmOwOZrEliTJmtMWbII5lxdBOxR4CyHkWEWYsJaVwLjLYKcUhYtziuvJW9IVYpXPOrcqmt8wxylnHauhsk4mzNhbYGpotaVx4QnPhtcBFpwgDXHKFcdbiINreYU2hdT804WIvWEiVFSJToI5Bs5waZ3bkheBdth5YyAcZfus1B60MsQQyhRdx6GMXMmRkCVmFnkDALdKBCV40ItHODgcxaCcA0rwPwHAtCkFQJwWSlhrBYwWEsWm6weCkAljE0JcwECYCYFgGI6pSAAGsQAaQ0PoTgkgomaF4PEjgvAzhVOyVoOYcBYAwEQAJFgcQ6DRHIJQX4/T6AxGAAoZgpwECoAIHwOg/kzgQAiPU0gERgjVChJwTJvw2CCBHAwWgWycmkCwCiIw4gTn4HtOUYEZwTmYFUGUf0KxYlSmaKs\%2BsERrjEChB4LA2zeDGzwCwQFcwqAGAmQANXxCOOIjBAUyEECIMQ7ApBIvkEoNQqzdCNAMEYFA1hrD6BfGcWAzA2AoBYMgUYtAbrAhiMbLwDBSlfjiRFAQ9yQQgkFJJUwSTLBmA0DsEEI41jNOaGUVoLgGDuE8PUfwsqugFCKJkRIyQBBDAaKQLIGqGDKp6DEEYkrygCHaIMeVwwmgtAqGMA1UwjX9A6FqvQowOj2tVVwOYChUnLD0MbTAKweBhIiXUk5jTVAfUDCCQMkgdjAGQMgDMTKWXZggIkqwlhbq4EIDPDJt0PB9IGWw5kXqgX1LZeUyp1SOC1NIKC6t0TYmNOaSAVpFbSCdJ6YJOI/ohkQEwPgU6eo9D8GRaIcQ6Kx2YpUOoE5uLSA3GuHEMFNbImkCbQ0zgI5/S9vDKgdMkbo2xvjYm5NxBmWsozIW0Z0RRJrDLVkiteSClFMoCG2tvAG1VM3XEzgrb205MrRUqp4SODio3asltT6gMfrMGG5t/6YPtLmAypIzhJBAA\%3D}{Compiler
  Explorer Link to Before/After Examples}


\chapter{Wording}

\section{Synopsis}

Modify 26.2 Header <ranges> synopsis

\begin{adjustwidth}{1cm}{1cm}
  \begin{addedblock}
    \begin{codeblock}
      // \ref{range.maybe}, maybe view
      template<copy_constructible T>
      requires @\seebelow@;
      class maybe_view;

      template <typename T>
      constexpr inline bool enable_borrowed_range<maybe_view<T*>> = true;

      template <typename T>
      constexpr inline bool enable_borrowed_range<maybe_view<reference_wrapper<T>>> = true;

      namespace views { inline constexpr @\unspec@ maybe = @\unspec@; }
    \end{codeblock}
  \end{addedblock}
\end{adjustwidth}

\rSec2[range.maybe]{Maybe View}

\rSec3[range.maybe.overview]{Overview}

\pnum
\tcode{maybe_view} is a range adaptor that produces a \libconcept{view} with cardinality 0 or 1. It adapts \libconcept{copyable} object types and \exposid{nullable} types. If the type is \exposid{nullable}, the view is empty if the \exposid{nullable} is empty.


\pnum
The name \tcode{views::maybe} denotes a customization point object ([customization.point.object]). For some subexpression \tcode{E}, the expression \tcode{views::maybe<E>} is expression-equivalent to:
\begin{itemize}
\item
  \tcode{maybe_view(E)}, the \libconcept{view} specified below, if the expression is well formed, where \tcode{\placeholdernc{decay-copy}(E)} is moved into the \tcode{maybe_view}
\item
 otherwise \tcode{views::maybe(E)} is ill-formed.
\end{itemize}


\begin{note}
  Whenever \tcode{views::maybe(E)} is a valid expression, it is a prvalue whose type models \libconcept{view}.
\end{note}
\pnum

\begin{example}
  \begin{codeblock}
  optional o{4};
  maybe_view m{o};
  for (int i : m)
  cout << i;        // prints 4
\end{codeblock}
\end{example}

\rSec3[range.maybe.nullable]{Concept nullable}

\pnum{}
Types that:

\begin{itemize}
\item - are contextually convertible to \tcode{bool}
\item are dereferenceable
\item have const references which are dereferenceable
\item the \tcode{iter_reference_t} of the type and the \tcode{iter_reference_t} of the const type, will :
  \begin{itemize}
  \item satisfy \tcode{is_lvalue_reference}
  \item satisfy \tcode{is_object} when the reference is removed
  \item for const pointers to the referred to types, satisfy \tcode{convertible_to}
  \end{itemize}
\item or are a reference_wrapper around a type that satifies \libconcept{nullable}
\end{itemize}
model the exposition only \libconcept{nullable} concept

\pnum{}
Given a value \tcode{i} of type \tcode{I}, \tcode{I} models \exposconcept{nullable} only if the expression \tcode{*i} is equality-preserving.
\begin{note}
  The expression \tcode{*i} is required to be valid via the exposition-only \exposconcept{nullable} concept.
\end{note}

\pnum{}
For convience, the exposition-only concepts \exposconcept{is-reference-wrapper-v}. \exposconcept{nuullable}, \exposconcept{nuullable_ref}, and \exposconcept{copyable_object} are used below.

\begin{codeblock}
// \expos{}

template <class T>
concept nullable =
    std::is_object_v<T> && requires(T& t, const T& ct) {
                               bool(ct);
                               *(t);
                               *(ct);
                           };

template <class T>
concept nullable_val =
    nullable<T> &&
    readable_references<std::iter_reference_t<T>,
                        std::iter_reference_t<const T>>;

template <typename, template <typename...> class>
inline constexpr bool is_v = false;

template <typename... Ts, template <typename...> class C>
inline constexpr bool is_v<C<Ts...>, C> = true;

template <class T>
concept nullable_ref = is_v<T, std::reference_wrapper> &&
                       nullable_val<typename T::type>;

template <class T>
inline constexpr bool is_reference_wrapper_v =
    is_v<T, std::reference_wrapper>;

template <class T>
concept copyable_object = (std::copy_constructible<T> &&
                           std::is_object_v<T>);
\end{codeblock}

\rSec3[range.maybe.view]{Class template \tcode{maybe_view}}

\begin{codeblock}

template <typename Value>
requires(copyable_object<Value>) class maybe_view
    : public ranges::view_interface<maybe_view<Value>> {
  private:
    std::optional<Value> @\exposid{value_}@; // \expos

  public:
    constexpr maybe_view() = default;

    constexpr explicit maybe_view(Value const& value);

    constexpr explicit maybe_view(Value&& value);

    template <class... Args>
    requires std::constructible_from<Value, Args...>
    constexpr maybe_view(std::in_place_t, Args&&... args);

    constexpr Value*       begin() noexcept;
    constexpr const Value* begin() const;
    constexpr Value*       end() noexcept;
    constexpr const Value* end() const noexcept;

    constexpr size_t size() const noexcept;

    constexpr Value* data() noexcept;

    constexpr const Value* data() const noexcept;
};

\end{codeblock}

%% BEGIN value defs
\begin{itemdecl}
  constexpr explicit maybe_view(Value const& maybe);
\end{itemdecl}
\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes value_ with maybe.
\end{itemdescr}

\begin{itemdecl}
  constexpr explicit maybe_view(Value&& maybe);
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes value_ with `std::move(maybe)`.
\end{itemdescr}

\begin{itemdecl}
  template<class... Args>
  constexpr maybe_view(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes value_ as if by \tcode{value_{in_place, forward<Args>(args)...}}.
\end{itemdescr}

\begin{itemdecl}
  constexpr T* begin() noexcept;
  constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns \tcode{data();}.
\end{itemdescr}

\begin{itemdecl}
  constexpr T* end() noexcept;
  constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns \tcode{data() + size();}.
\end{itemdescr}

\begin{itemdecl}
  static constexpr size_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    return bool(value_);
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
  constexpr T* data() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \returns \tcode{std::addressof(*value_);}
\end{itemdescr}

\begin{itemdecl}
  constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    return std::addressof(*value_);
  \end{codeblock}
\end{itemdescr}

\begin{codeblock}

template <typename Maybe>
requires(copyable_object<Maybe> &&
         (nullable_val<Maybe> || nullable_ref<Maybe>))
    class maybe_view<Maybe> : public ranges::view_interface<maybe_view<Maybe>> {
      private:
        using T = @\seebelow@;

        @\exposid{copyable-box}@<Maybe> @\exposid{value_}@; // \expos

      public:
        constexpr maybe_view() = default;

        constexpr explicit maybe_view(Maybe const& maybe);

        constexpr explicit maybe_view(Maybe&& maybe);

        template <class... Args>
        requires std::constructible_from<Maybe, Args...> constexpr
        maybe_view(std::in_place_t, Args&&... args);

        constexpr T*       begin() noexcept;
        constexpr const T* begin() const noexcept;
        constexpr T*       end() noexcept;
        constexpr const T* end() const noexcept;

        constexpr size_t size() const noexcept;

        constexpr T* data() noexcept;

        constexpr const T* data() const noexcept;
    };
\end{codeblock}

\begin{codeblock}

// For Exposition
using T = std::remove_reference_t<
    iter_reference_t<typename unwrap_reference_t<Maybe>>>;

\end{codeblock}

%% BEGIN nullable defs
\begin{itemdecl}
constexpr explicit maybe_view(Maybe const& maybe);
\end{itemdecl}
\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes value\_ with maybe.
\end{itemdescr}

\begin{itemdecl}
constexpr explicit maybe_view(Maybe&& maybe);
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes value\_ with `std::move(maybe)`.
\end{itemdescr}

\begin{itemdecl}
template<class... Args>
constexpr maybe_view(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Initializes value\_ as if by `value_{in_place, forward<Args>(args)...}`.
\end{itemdescr}

\begin{itemdecl}
constexpr T* begin() noexcept;
constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to: `return data();`.
\end{itemdescr}

\begin{itemdecl}
constexpr T* end() noexcept;
constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to: `return data() + size();`.
\end{itemdescr}

\begin{itemdecl}
static constexpr size_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    if constexpr (@*is-reference-wrapper-v*@<Maybe>) {
      return bool(value_.get().get());
    } else {
      return bool(value_.get());
    }
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
constexpr T* data() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    Maybe& m = *value_;
    if constexpr (@*is-reference-wrapper-v*@<Maybe>) {
      return m.get() ? addressof(*(m.get())) : nullptr;
    } else {
      return m ? addressof(*m) : nullptr;
    }
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum{}
  \effects{}
  Equivalent to:

  \begin{codeblock}
    const Maybe& m = *value_;
    if constexpr (@*is-reference-wrapper-v*@<Maybe>) {
      return m.get() ? addressof(*(m.get())) : nullptr;
    } else {
      return m ? addressof(*m) : nullptr;
    }
  \end{codeblock}
\end{itemdescr}

\chapter{Impact on the standard}

A pure library extension, affecting no other parts of the library or language.

The proposed changes are relative to the current working draft~\cite{N4910}.

\chapter*{Document history}

\begin{itemize}
\item \textbf{Changes since R7}
  \begin{itemize}
  \item Update all Wording.
  \item Convert to standards latex macros for wording.
  \item Removed discussion of list comprehension desugaring - will move to yield_if paper.
  \end{itemize}
\item \textbf{Changes since R6}
  \begin{itemize}
  \item Extend to all object types in order to support list comprehension
  \item Track working draft changes for Ranges
  \item Add discussion of _borrowed_range_
  \item Add an example where pipelines use references.
  \item Add support for proxy references (explore std::pointer_traits, etc).
  \item Make std::views::maybe model std::ranges::borrowed_range if it's not holding the object by value.
  \item Add a const propagation section discussing options, existing precedent and proposing the option that the author suggests.
  \end{itemize}
\item \textbf{Changes since R5}
  \begin{itemize}
  \item Fix reversed before/after table entry
  \item Update to match C++20 style [@N4849] and changes in Ranges since [@P0896R3]
  \item size is now size_t, like other ranges are also
  \item add synopsis for adding to `<ranges>` header
  \item Wording clean up, formatting, typesetting
  \item Add implementation notes and references
  \end{itemize}
\item \textbf{Changes since R4}
  \begin{itemize}
  \item Use std::unwrap\_reference
  \item Remove conditional `noexcept`ness
  \item Adopted the great concept renaming
  \end{itemize}
\item \textbf{Changes since R3}
  \begin{itemize}
  \item Always Capture
  \item Support reference\_wrapper
  \end{itemize}
\item \textbf{Changes since R2}
  \begin{itemize}
  \item Reflects current code as reviewed
  \item Nullable concept specification
  \item Remove Readable as part of the specification, use the useful requirements from Readable
  \end{itemize}
  \begin{itemize}
  \item Wording for views::maybe as proposed
  \item Appendix A: wording for a view\_maybe that always captures
  \end{itemize}
\item \textbf{Changes since R1}
  \begin{itemize}
  \item Refer to views::all
  \item Use wording 'range adaptor object'
  \end{itemize}
\item \textbf{Changes since R0}
  \begin{itemize}
  \item Remove customization point objects
  \item Concept `Nullable`, for exposition
  \item Capture rvalues by decay copy
  \item Remove maybe\_view as a specified type
  \end{itemize}
\end{itemize}

\renewcommand{\bibname}{References}
\bibliographystyle{alpha}
\bibliography{wg21}

\end{document}
